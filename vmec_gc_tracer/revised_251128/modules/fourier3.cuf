module fourier3
    implicit none
contains

    pure function compc_arg(n, coeff, cosvals) result(output)
        integer,  intent(in)           :: n
        real(8), intent(in), contiguous :: coeff(:)
        real(8), intent(in), contiguous :: cosvals(:)
        real(8) :: output
        integer :: i

        output = 0.0d0
        !$omp simd reduction(+:output)
        do i = 1, n
            output = output + coeff(i) * cosvals(i)
        end do
    end function compc_arg

    pure function comps_arg(n, coeff, sinvals) result(output)
        integer,  intent(in)            :: n
        real(8), intent(in), contiguous :: coeff(:)
        real(8), intent(in), contiguous :: sinvals(:)
        real(8) :: output
        integer :: i    

        output = 0.0d0
        !$omp simd reduction(+:output)
        do i = 1, n
            output = output + coeff(i) * sinvals(i)
        end do
    end function comps_arg

    pure function compc_dtheta_arg(xm, coeff, sinvals) result(output)
        integer,  intent(in), contiguous :: xm(:)
        real(8), intent(in), contiguous  :: coeff(:)
        real(8), intent(in), contiguous  :: sinvals(:)
        real(8) :: output
        integer :: i, n
        n = size(coeff)
        output = 0.0d0
        !$omp simd reduction(+:output)
        do i = 1, n
            output = output - coeff(i) * xm(i) * sinvals(i)
        end do
    end function compc_dtheta_arg

    pure function compc_dzeta_arg(xn, coeff, sinvals) result(output)
        integer,  intent(in), contiguous :: xn(:)
        real(8), intent(in), contiguous  :: coeff(:)
        real(8), intent(in), contiguous  :: sinvals(:)
        real(8) :: output
        integer :: i, n
        real(8), parameter :: half = 0.5d0

        n = size(coeff)
        output = 0.0d0
        !$omp simd reduction(+:output)
        do i = 1, n
            output = output + coeff(i) * (xn(i)*half) * sinvals(i)
        end do
    end function compc_dzeta_arg

    pure subroutine crossp2(a,b,j,c)
        real(8), intent(in)  :: a(3), b(3)
        real(8), intent(in)  :: j
        real(8), intent(out) :: c(3)
        c(1) = (a(2)*b(3) - a(3)*b(2))/j
        c(2) = (a(3)*b(1) - a(1)*b(3))/j
        c(3) = (a(1)*b(2) - a(2)*b(1))/j
    end subroutine crossp2

end module fourier3
